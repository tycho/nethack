Path: tekred!tekgen!tektronix!uunet!mcvax!inria!axis!jcc
From: jcc@axis.fr (Jean-Christophe Collet)
Newsgroups: rec.games.hack
Subject: Nethack 2.3 Patches and Enhancements
Keywords: Nethack, patches
Message-ID: <371@axis.fr>
Date: 11 May 88 16:08:45 GMT
Organization: Axis Digital, Paris
Lines: 1779


Hello there,

Here are a few patches and enhancements for nethack 2.3 :

	1) BUGFIX : now, if a Nymph steals your blinfold or your badge,
	   you're no longer "Blinfolded / Badged". (in steal.c)

	2) LIGHT SWORD : very similar to laser swords, this weapon
	   is very powerful but rare and presents some inconveniences.
	   I will post SPOILERS for that new feature if asked.
	   Note that you have to insert
	   #define YODA  /* :-) */
	   in your config.h.

	3) Graphics enhancement for terminals with an alternate charset
	   (semi-graphic characters). I've fully implemented corners,
	   cross walls, etc...
	   That makes mazes very pretty.
	   the HACKOPTIONS variable is used with the 'graphics' option.
	   Also used the two capacities "as" & "ae" in TERMCAP ("smacs"
	   and "rmacs" in TERMINFO).
	   Two chars are needed for each symbol, the first one is the
	   ascii value needed and the second is either 'g' for graphic
	   charset or 'n' for standard charset.
	   exemple : for a vt100 I've defined :
HACKOPTIONS="graphics: nxgqglgkgmgjg\`g.nag<n>n^n}n{n\\n\"n#nngwgvgtgug"
	   the symbols are :
	   stone, vertical wall, horizontal wall, top left corner,
	   top right corner, bottom left corner, bottom right corner,
	   door, room, corridor, upstairs, downstairs, trap, pool, fountain,
	   throne, spider web, kitchen sink, cross wall, T up wall,
	   T down wall, T left wall, T right wall.
	   Note that you have to insert
	   #define JCC
	   in your config.h to make these features available.

I will happily discuss any points of those patches with anybody !

Happy hacking!
jcc

-------------------------------------------------------------------------------
jcc@axis.fr          ! "An artificial intelligence is better than none !"
mcvax!inria!axis!jcc ! "Artificial intelligence matches natural stupidity !"
-------------------------------------------------------------------------------

------ CUT HERE --- CUT HERE --- CUT HERE --- CUT HERE --- CUT HERE ------	
*** apply.c.orig	Wed May 11 10:28:24 1988
--- apply.c	Wed May 11 11:54:46 1988
***************
*** 18,23
  #ifdef KAA
  extern boolean unweapon;
  #endif
  static use_camera(), use_ice_box(), use_whistle();
  static use_magic_whistle(), use_pick_axe();
  #ifdef MARKER

--- 18,26 -----
  #ifdef KAA
  extern boolean unweapon;
  #endif
+ #ifdef YODA
+ extern char FirstTime;	/* First use of the light sword */
+ #endif
  static use_camera(), use_ice_box(), use_whistle();
  static use_magic_whistle(), use_pick_axe();
  #ifdef MARKER
***************
*** 102,107
  		    seeoff(0);
  		} else pline("You are already wearing a blindfold!");
  		break;
   	case BADGE:
   		if (Badged && obj->owornmask) {
   		    pline("You remove the badge.");

--- 105,142 -----
  		    seeoff(0);
  		} else pline("You are already wearing a blindfold!");
  		break;
+ #ifdef YODA
+ 	case BATTERY: {
+ 		struct obj *otmp;
+ 		otmp = getobj("#","apply to");
+ 		if (!otmp) {
+ 			nomul(0);
+ 			return(0);
+ 		}
+ 		if (otmp->otyp != LIGHT_SWORD && otmp->otyp != SWORD_HILT) {
+ 			pline("That's a silly thing to apply batteries!");
+ 			nomul(0);
+ 			return(0);
+ 		}
+ 		pline("You succeeded in inserting the battery into the hilt.");
+ 		pline("You can feel a new energy to flow in it...");
+ 		OPOWER(otmp) = 500;
+ 		useup(obj);
+ 		if (otmp->otyp == SWORD_HILT && uwep == otmp) {
+ 			if (FirstTime) {
+ 				if (!Blind) 
+ 					pline("A blade of light appears from the hilt!");
+ 				pline("You ear a distant voice saying :");
+ 				pline("'May the Source be with you...'");
+ 				FirstTime = 0;
+ 			} else
+ 				if (!Blind) 
+ 					pline("A blade of light appears from the hilt!");
+ 			uwep->otyp = LIGHT_SWORD;
+ 		}
+ 		}
+ 		break;
+ #endif
   	case BADGE:
   		if (Badged && obj->owornmask) {
   		    pline("You remove the badge.");
***************
*** 259,264
  			return(0);
  		}
  		setuwep((struct obj *) 0);
  	}
  	current_ice_box->owt += obj->owt;
  	freeinv(obj);

--- 294,306 -----
  			return(0);
  		}
  		setuwep((struct obj *) 0);
+ #ifdef YODA
+ 		if (obj->otyp == LIGHT_SWORD) {
+ 			if (!Blind) 
+ 				pline("The blade of light disappears!");
+ 			obj->otyp = SWORD_HILT;			
+ 		}
+ #endif
  	}
  	current_ice_box->owt += obj->owt;
  	freeinv(obj);
***************
*** 265,270
  	obj->o_cnt_id = current_ice_box->o_id;
  	obj->nobj = fcobj;
  	fcobj = obj;
  	obj->age = moves - obj->age;	/* actual age */
  	return(1);
  }

--- 307,315 -----
  	obj->o_cnt_id = current_ice_box->o_id;
  	obj->nobj = fcobj;
  	fcobj = obj;
+ #ifdef YODA
+ 	if (obj->otyp != SWORD_HILT) 
+ #endif
  	obj->age = moves - obj->age;	/* actual age */
  	return(1);
  }
***************
*** 284,289
  		otmp->nobj = obj->nobj;
  	}
  	current_ice_box->owt -= obj->owt;
  	obj->age = moves - obj->age;	/* simulated point of time */
  	(void) addinv(obj);
  }

--- 329,339 -----
  		otmp->nobj = obj->nobj;
  	}
  	current_ice_box->owt -= obj->owt;
+ #ifdef YODA
+ 	if (obj->otyp == SWORD_HILT)
+ 		OPOWER(obj) += rn1(100,100);	/* Supra conductivity ? */
+ 	else
+ #endif
  	obj->age = moves - obj->age;	/* simulated point of time */
  	(void) addinv(obj);
  }
*** bones.c.orig	Wed May 11 10:29:15 1988
--- bones.c	Wed May 11 09:56:03 1988
***************
*** 54,59
  			invent = 0;	/* superfluous */
  			break;
  		}
  		otmp = otmp->nobj;
  	}
  	/* spill any contained objects - added by GAN 03/23/87 */

--- 54,63 -----
  			invent = 0;	/* superfluous */
  			break;
  		}
+ #ifdef YODA
+ 		if (otmp->otyp == LIGHT_SWORD) 
+ 			otmp->otyp = SWORD_HILT;
+ #endif
  		otmp = otmp->nobj;
  	}
  	/* spill any contained objects - added by GAN 03/23/87 */
*** config.h.orig	Wed May 11 12:28:11 1988
--- config.h	Wed May 11 12:28:53 1988
***************
*** 229,233
  #define THEOLOGY	/* Smarter gods - The Unknown Hacker */
  #define	STOOGES		/* Three wild and crazy guys - Bruce Mewborne */
  #define SINKS		/* Kitchen sinks - Janet Walz */
  
  #if defined(MSDOS) && defined(GRAPHICS)

--- 229,235 -----
  #define THEOLOGY	/* Smarter gods - The Unknown Hacker */
  #define	STOOGES		/* Three wild and crazy guys - Bruce Mewborne */
  #define SINKS		/* Kitchen sinks - Janet Walz */
+ #define YODA		/* Light Sword Code - JC Collet */
+ #define JCC		/* Some change for display - JC Collet */
  
  #if defined(MSDOS) && defined(GRAPHICS)
*** decl.c.orig	Wed May 11 10:35:44 1988
--- decl.c	Wed May 11 09:56:05 1988
***************
*** 20,25
  #ifdef SINKS
      '#',
  #endif
  };
  
  struct symbols showsyms;	/* will contain the symbols actually used */

--- 20,28 -----
  #ifdef SINKS
      '#',
  #endif
+ #ifdef JCC
+     '-','-','-','-','-',
+ #endif
  };
  
  struct symbols showsyms;	/* will contain the symbols actually used */
*** do.c.orig	Wed May 11 10:36:35 1988
--- do.c	Wed May 11 09:56:06 1988
***************
*** 56,61
  			pline("Your weapon is welded to your hand!");
  			return(0);
  		}
  		setuwep((struct obj *) 0);
  	}
  #ifdef WALKIES

--- 56,65 -----
  			pline("Your weapon is welded to your hand!");
  			return(0);
  		}
+ #ifdef YODA
+ 		if (obj->otyp == LIGHT_SWORD) 
+ 			obj->otyp = SWORD_HILT;
+ #endif
  		setuwep((struct obj *) 0);
  	}
  #ifdef WALKIES
*** dothrow.c.orig	Wed May 11 10:37:56 1988
--- dothrow.c	Wed May 11 09:56:08 1988
***************
*** 1,4
- 
  /*	SCCS Id: @(#)dothrow.c	2.3	88/02/02
  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
  

--- 1,3 -----
  /*	SCCS Id: @(#)dothrow.c	2.3	88/02/02
  /* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
  
***************
*** 48,53
  			setuwep(splitobj(obj, 1));
  		else
  			setuwep((struct obj *) 0);
  	}
  	else if(obj->quan > 1)
  		(void) splitobj(obj, 1);

--- 47,56 -----
  			setuwep(splitobj(obj, 1));
  		else
  			setuwep((struct obj *) 0);
+ #ifdef YODA
+ 		if (obj->otyp == LIGHT_SWORD) 
+ 			obj->otyp = SWORD_HILT;
+ #endif
  	}
  	else if(obj->quan > 1)
  		(void) splitobj(obj, 1);
*** fight.c.orig	Wed May 11 10:39:38 1988
--- fight.c	Wed May 11 09:56:10 1988
***************
*** 381,386
  		if(obj->olet == WEAPON_SYM && obj->dknown && index("VWZ &",
  				mon->data->mlet)) tmp += rn2(4);
  #endif
  		if(!thrown && obj == uwep && obj->otyp == BOOMERANG
  		 && !rn2(3)){
  		  pline("As you hit %s, the boomerang breaks into splinters.",

--- 381,400 -----
  		if(obj->olet == WEAPON_SYM && obj->dknown && index("VWZ &",
  				mon->data->mlet)) tmp += rn2(4);
  #endif
+ #ifdef YODA
+ 		if (obj->otyp == LIGHT_SWORD && mon->data->mlet == ';') {
+ 			/* That was really a bad idea */
+ 			pline("As soon a you hit the %s,",monnam(mon));
+ 			pline("an extremely powerful lightning bolt erupts");
+ 			pline("from your sword, destroying it,");
+ 			pline("getting you and the %s blasted!",monnam(mon));
+ 			tmp += rn2(40);	/* Hurt the monster */
+ 			freeinv(obj);	/* Destroy the sword */
+ 			setworn((struct obj *) 0, obj->owornmask);
+ 			obfree(obj, (struct obj *) 0);
+ 			losehp(rn2(40),"lightning bolt"); /* Hurt player */
+ 		}
+ #endif
  		if(!thrown && obj == uwep && obj->otyp == BOOMERANG
  		 && !rn2(3)){
  		  pline("As you hit %s, the boomerang breaks into splinters.",
***************
*** 467,472
  	}
  	if(tmp < 1) tmp = 1;
  	mon->mhp -= tmp;
  	if(mon->mhp < 1) {
  		killed(mon);
  		return(FALSE);

--- 481,495 -----
  	}
  	if(tmp < 1) tmp = 1;
  	mon->mhp -= tmp;
+ #ifdef YODA
+ 	if (obj->otyp == LIGHT_SWORD && mon->data->mlet == 'T') {
+ 		mon->mhpmax -= tmp;	/* The light sword burns flesh */
+ 		if (mon->mhpmax < 1) {
+ 			xkilled(mon,3); /* No Corpse */
+ 			return(FALSE);
+ 		}
+ 	}
+ #endif /* YODA */
  	if(mon->mhp < 1) {
  		killed(mon);
  		return(FALSE);
***************
*** 621,626
  		else if(uwep->otyp == CRYSKNIFE) tmp += 3;
  		else if(uwep->otyp == SPEAR &&
  			index("XDne", mdat->mlet)) tmp += 2;
  	}
  	if(mtmp->msleep) {
  		mtmp->msleep = 0;

--- 644,652 -----
  		else if(uwep->otyp == CRYSKNIFE) tmp += 3;
  		else if(uwep->otyp == SPEAR &&
  			index("XDne", mdat->mlet)) tmp += 2;
+ #ifdef YODA
+ 		else if (uwep->otyp == LIGHT_SWORD) tmp += 5;
+ #endif
  	}
  	if(mtmp->msleep) {
  		mtmp->msleep = 0;
*** fountain.c.orig	Wed May 11 10:41:13 1988
--- fountain.c	Wed May 11 09:56:11 1988
***************
*** 243,248
  	register int fate = rnd(30);
  
  	if(Levitation) 	pline("You are floating high above the fountain.");
  	else if(fate<10)
  		if(!obj->rustfree &&
  			/* Only swords affected here */

--- 243,268 -----
  	register int fate = rnd(30);
  
  	if(Levitation) 	pline("You are floating high above the fountain.");
+ #ifdef YODA
+ 	if (obj->otyp == LIGHT_SWORD) {
+ 		/* Yet Another Bad Idea */
+ 		pline("As your %s enters water,",xname(obj));
+ 		pline("an extremely powerful lightning bolt erupts from your sword,");
+ 		pline("destroying it and getting you blasted!");
+ 		freeinv(obj);	/* Destroy the sword */
+ 		setworn((struct obj *) 0, obj->owornmask);
+ 		obfree(obj, (struct obj *) 0);
+ 		losehp(rn2(40),"lightning bolt");
+ 	}
+ 	else if (obj->otyp == SWORD_HILT) {
+ 		/* Water doesn't do anything good to batteries */
+ 		if (OPOWER(obj) > 0) {
+ 			pline("GLOUB %%%% Pschhhhhhh....");
+ 			OPOWER(obj) -= 100;
+ 		} else
+ 			pline("GLOUB %%%%%");
+ 	}
+ #endif
  	else if(fate<10)
  		if(!obj->rustfree &&
  			/* Only swords affected here */
*** lev.c.orig	Wed May 11 10:42:33 1988
--- lev.c	Wed May 11 09:56:13 1988
***************
*** 281,286
  					break;
  				/* Now the ugly stuff */
  				case HWALL:
  				  up = (y > 0) ? levl[x][y-1].typ : 0;
  				  dn = (y < ROWNO-1) ?levl[x][y+1].typ : 0;
  				  lt = (x > 0) ? levl[x-1][y].typ : 0;

--- 281,287 -----
  					break;
  				/* Now the ugly stuff */
  				case HWALL:
+ #ifndef JCC
  				  up = (y > 0) ? levl[x][y-1].typ : 0;
  				  dn = (y < ROWNO-1) ?levl[x][y+1].typ : 0;
  				  lt = (x > 0) ? levl[x-1][y].typ : 0;
***************
*** 304,309
  				  else if (osym == osymbol.hwall)
  					nsym = showsyms.hwall;
  				  break;
  				default:
  					break;
  				}

--- 305,351 -----
  				  else if (osym == osymbol.hwall)
  					nsym = showsyms.hwall;
  				  break;
+ #else
+ 				  if (osym == osymbol.hwall)
+ 					nsym = showsyms.hwall;
+ 				  break;
+ 				case TLCORNER:
+ 					if (osym == osymbol.tlcorn) 
+ 						nsym = showsyms.tlcorn;
+ 					break;
+ 				case TRCORNER:
+ 					if (osym == osymbol.trcorn) 
+ 						nsym = showsyms.trcorn;
+ 					break;
+ 				case BLCORNER:
+ 					if (osym == osymbol.blcorn) 
+ 						nsym = showsyms.blcorn;
+ 					break;
+ 				case BRCORNER:
+ 					if (osym == osymbol.brcorn) 
+ 						nsym = showsyms.brcorn;
+ 					break;
+ 				case CROSSWALL:
+ 					if (osym == osymbol.crwall) 
+ 						nsym = showsyms.crwall;
+ 					break;
+ 				case TUPWALL:
+ 					if (osym == osymbol.twall) 
+ 						nsym = showsyms.twall;
+ 					break;
+ 				case TDOWNWALL:
+ 					if (osym == osymbol.tdwall) 
+ 						nsym = showsyms.tdwall;
+ 					break;
+ 				case TRIGHTWALL:
+ 					if (osym == osymbol.trwall) 
+ 						nsym = showsyms.trwall;
+ 					break;
+ 				case TLEFTWALL:
+ 					if (osym == osymbol.tlwall) 
+ 						nsym = showsyms.tlwall;
+ 					break;
+ #endif
  				default:
  					break;
  				}
*** mklev.c.orig	Wed May 11 10:43:59 1988
--- mklev.c	Wed May 11 09:56:31 1988
***************
*** 514,519
  		levl[x][y].scrsym = ROOM_SYM;
  		levl[x][y].typ = ROOM;
  	}
  	levl[lowx-1][lowy-1].scrsym = TLCORN_SYM;
  	levl[hix+1][lowy-1].scrsym = TRCORN_SYM;
  	levl[lowx-1][hiy+1].scrsym = BLCORN_SYM;

--- 514,525 -----
  		levl[x][y].scrsym = ROOM_SYM;
  		levl[x][y].typ = ROOM;
  	}
+ #ifdef JCC
+ 	levl[lowx-1][lowy-1].typ = TLCORNER;
+ 	levl[hix+1][lowy-1].typ = TRCORNER;
+ 	levl[lowx-1][hiy+1].typ = BLCORNER;
+ 	levl[hix+1][hiy+1].typ = BRCORNER;
+ #endif
  	levl[lowx-1][lowy-1].scrsym = TLCORN_SYM;
  	levl[hix+1][lowy-1].scrsym = TRCORN_SYM;
  	levl[lowx-1][hiy+1].scrsym = BLCORN_SYM;
*** mkmaze.c.orig	Wed May 11 10:44:46 1988
--- mkmaze.c	Wed May 11 09:56:32 1988
***************
*** 74,79
  		for(y = 2; y < ROWNO-1; y++) {
  			switch(levl[x][y].typ) {
  			case HWALL:
  				levl[x][y].scrsym = HWALL_SYM;
  				break;
  			case ROOM:

--- 74,139 -----
  		for(y = 2; y < ROWNO-1; y++) {
  			switch(levl[x][y].typ) {
  			case HWALL:
+ #ifdef JCC
+ #define ISWALL(x,y)	((x)>1 && (y)>1 && (x)<COLNO-1 && (y)<ROWNO-1 && \
+ 			levl[x][y].typ <= TRIGHTWALL)
+ 				if (ISWALL(x,y-1)) 
+ 				   if (ISWALL(x,y+1))
+ 				      if (ISWALL(x-1,y)) 
+ 					 if (ISWALL(x+1,y)) {
+ 						levl[x][y].scrsym = CRWALL_SYM; /* -+- */
+ 						levl[x][y].typ = CROSSWALL;
+ 					 } else {
+ 						levl[x][y].scrsym = TRIGHTWALL_SYM; /* -| */
+ 						levl[x][y].typ = TRIGHTWALL;
+ 				      } else 
+ 					 if (ISWALL(x+1,y)) {
+ 						levl[x][y].scrsym = TLEFTWALL_SYM; /* |- */
+ 						levl[x][y].typ = TLEFTWALL;
+ 					 }
+ 					 else {
+ 						levl[x][y].scrsym = VWALL_SYM; /* | */
+ 						levl[x][y].typ = VWALL;
+ 					 }
+ 				   else
+ 				      if (ISWALL(x-1,y)) 
+ 					 if (ISWALL(x+1,y)) {			    /*  |  */
+ 						 levl[x][y].scrsym = TDOWNWALL_SYM; /* -+- */
+ 						 levl[x][y].typ = TDOWNWALL;
+ 					 } else {				 /*  | */
+ 						 levl[x][y].scrsym = BRCORN_SYM; /* -+ */
+ 						 levl[x][y].typ = BRCORNER;
+ 				      } else
+ 					 if (ISWALL(x+1,y)) {			 /* |  */
+ 						 levl[x][y].scrsym = BLCORN_SYM; /* +- */
+ 						 levl[x][y].typ = BLCORNER;
+ 					 } else {
+ 						 levl[x][y].scrsym = VWALL_SYM; /* | */
+ 						 levl[x][y].typ = VWALL;
+ 					 }
+ 				else
+ 				   if (ISWALL(x,y+1))
+ 				      if (ISWALL(x-1,y)) 
+ 				         if (ISWALL(x+1,y)) {		      /* -+- */
+ 					     levl[x][y].scrsym = TUPWALL_SYM; /*  |  */
+ 					     levl[x][y].typ = TUPWALL;
+ 				         } else {			     /* -+ */
+ 					     levl[x][y].scrsym = TRCORN_SYM; /*  | */
+ 					     levl[x][y].typ = TRCORNER;
+ 				      } else
+ 				         if (ISWALL(x+1,y)) {		     /* +- */
+ 					     levl[x][y].scrsym = TLCORN_SYM; /* |  */
+ 					     levl[x][y].typ = TLCORNER;
+ 				         } else {
+ 					     levl[x][y].scrsym = VWALL_SYM; /* | */
+ 					     levl[x][y].typ = VWALL;
+ 					 }
+ 				   else {
+ 					   levl[x][y].scrsym = HWALL_SYM;
+ 					   levl[x][y].typ = HWALL;
+ 				   }
+ #undef ISWALL
+ #else
  				levl[x][y].scrsym = HWALL_SYM;
  #endif /* JCC */
  				break;
***************
*** 75,80
  			switch(levl[x][y].typ) {
  			case HWALL:
  				levl[x][y].scrsym = HWALL_SYM;
  				break;
  			case ROOM:
  				levl[x][y].scrsym = ROOM_SYM;

--- 135,141 -----
  #undef ISWALL
  #else
  				levl[x][y].scrsym = HWALL_SYM;
+ #endif /* JCC */
  				break;
  			case ROOM:
  				levl[x][y].scrsym = ROOM_SYM;
*** mkobj.c.orig	Wed May 11 10:51:28 1988
--- mkobj.c	Wed May 11 10:19:10 1988
***************
*** 111,116
  		    let) ? 0 : 1;
  	switch(let) {
  	case WEAPON_SYM:
  		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
  		if(!rn2(11)) otmp->spe = rne(2);
  		else if(!rn2(10)) {

--- 111,122 -----
  		    let) ? 0 : 1;
  	switch(let) {
  	case WEAPON_SYM:
+ #ifdef YODA
+ 		otmp->quan=((otmp->otyp <= ROCK) && (otmp->otyp != SWORD_HILT))
+ 			     ? rn1(6,6) : 1;
+ 		if (otmp->otyp == SWORD_HILT)
+ 			OPOWER(otmp) = 500;
+ #else
  		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
  #endif
  		if(!rn2(11)) otmp->spe = rne(2);
***************
*** 112,117
  	switch(let) {
  	case WEAPON_SYM:
  		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
  		if(!rn2(11)) otmp->spe = rne(2);
  		else if(!rn2(10)) {
  			otmp->cursed = 1;

--- 118,124 -----
  			OPOWER(otmp) = 500;
  #else
  		otmp->quan = (otmp->otyp <= ROCK) ? rn1(6,6) : 1;
+ #endif
  		if(!rn2(11)) otmp->spe = rne(2);
  		else if(!rn2(10)) {
  			otmp->cursed = 1;
*** obj.h.orig	Wed May 11 10:52:17 1988
--- obj.h	Wed May 11 10:19:43 1988
***************
*** 62,65
  #define	ONAME(otmp)	((char *) otmp->oextra)
  #define	OGOLD(otmp)	(otmp->oextra[0])
  
  #endif

--- 62,69 -----
  #define	ONAME(otmp)	((char *) otmp->oextra)
  #define	OGOLD(otmp)	(otmp->oextra[0])
  
+ #ifdef YODA
+ #define OPOWER(otmp)	otmp->age
+ #endif
+ 
  #endif
*** objclass.h.orig	Wed May 11 10:57:21 1988
--- objclass.h	Wed May 11 11:44:55 1988
*** objects.h.orig	Wed May 11 10:55:11 1988
--- objects.h	Wed May 11 10:21:10 1988
***************
*** 123,128
  	WEAPON("mace",		6, 3, 6, 7), /* +1 small */
  	WEAPON("axe",		5, 3, 6, 4),
  	WEAPON("flail",		5, 3, 6, 5), /* +1 small, +1d4 large */
  	WEAPON("long sword",	5, 3, 8, 12),
  	WEAPON("two-handed sword",	4, 4, 12, 6), /* +2d6 large */
  	WEAPON("dagger",	4, 3, 4, 3),

--- 123,132 -----
  	WEAPON("mace",		6, 3, 6, 7), /* +1 small */
  	WEAPON("axe",		5, 3, 6, 4),
  	WEAPON("flail",		5, 3, 6, 5), /* +1 small, +1d4 large */
+ #ifdef YODA
+ 	WEAPON("long sword",	4, 3, 8, 12),
+ 	WEAPON("light sword",	0, 1, 15, 15), /* +5 to hit */
+ #else
  	WEAPON("long sword",	5, 3, 8, 12),
  #endif
  	WEAPON("two-handed sword",	4, 4, 12, 6), /* +2d6 large */
***************
*** 124,129
  	WEAPON("axe",		5, 3, 6, 4),
  	WEAPON("flail",		5, 3, 6, 5), /* +1 small, +1d4 large */
  	WEAPON("long sword",	5, 3, 8, 12),
  	WEAPON("two-handed sword",	4, 4, 12, 6), /* +2d6 large */
  	WEAPON("dagger",	4, 3, 4, 3),
  	WEAPON("worm tooth",	0, 4, 2, 2),

--- 128,134 -----
  	WEAPON("light sword",	0, 1, 15, 15), /* +5 to hit */
  #else
  	WEAPON("long sword",	5, 3, 8, 12),
+ #endif
  	WEAPON("two-handed sword",	4, 4, 12, 6), /* +2d6 large */
  	WEAPON("dagger",	4, 3, 4, 3),
  	WEAPON("worm tooth",	0, 4, 2, 2),
***************
*** 154,159
  	WEAPON("bow",		4, 3, 4, 6),
  	WEAPON("sling",		4, 3, 6, 6),
  	WEAPON("crossbow",	5, 3, 4, 6),
  #ifdef WALKIES
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 51, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },

--- 159,168 -----
  	WEAPON("bow",		4, 3, 4, 6),
  	WEAPON("sling",		4, 3, 6, 6),
  	WEAPON("crossbow",	5, 3, 4, 6),
+ #ifdef  YODA
+ 	WEAPON("sword hilt",	1, 1, 2, 2),
+ #endif
+ 
  #ifdef WALKIES
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 51, 0, 2, 0, 0, 0 },
  #ifdef YODA
***************
*** 156,161
  	WEAPON("crossbow",	5, 3, 4, 6),
  #ifdef WALKIES
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 51, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },
  #else
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },

--- 165,173 -----
  
  #ifdef WALKIES
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 51, 0, 2, 0, 0, 0 },
+ #ifdef YODA
+ 	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 14, 0, 20, 0, 0, 0 },
+ #else
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },
  #endif
  #else
***************
*** 157,162
  #ifdef WALKIES
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 51, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },
  #else
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 16, 0, 20, 0, 0, 0 },

--- 169,175 -----
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 14, 0, 20, 0, 0, 0 },
  #else
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },
+ #endif
  #else
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },
  #ifdef YODA
***************
*** 159,164
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 26, 0, 20, 0, 0, 0 },
  #else
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 16, 0, 20, 0, 0, 0 },
  #endif
  	{ "magic whistle", "whistle", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },

--- 172,180 -----
  #endif
  #else
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },
+ #ifdef YODA
+ 	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 14, 0, 20, 0, 0, 0 },
+ #else
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 16, 0, 20, 0, 0, 0 },
  #endif
  #endif
***************
*** 161,166
  	{ "whistle", "whistle", NULL, 0, 0, TOOL_SYM, 71, 0, 2, 0, 0, 0 },
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 16, 0, 20, 0, 0, 0 },
  #endif
  	{ "magic whistle", "whistle", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },
  #ifdef RPH
  	{ "blindfold", "blindfold", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },

--- 177,183 -----
  #else
  	{ "leash", NULL, NULL, 1, 0, TOOL_SYM, 16, 0, 20, 0, 0, 0 },
  #endif
+ #endif
  	{ "magic whistle", "whistle", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },
  #ifdef RPH
  	{ "blindfold", "blindfold", NULL, 0, 0, TOOL_SYM, 5, 0, 2, 0, 0, 0 },
***************
*** 178,183
   	{ "lamp", "lamp", NULL, 0, 0, TOOL_SYM, 10, 0, 10, 0, 0, 0 },
   	{ "magic lamp", "lamp", NULL, 0, 0, TOOL_SYM, 2, 0, 10, 0, 0, 0 },
   	{ "badge", "badge", NULL, 0, 0, TOOL_SYM, 1, 0, 2, 0, 0, 0 },
  
  	{ "heavy iron ball", NULL, NULL, 1, 0,
  		BALL_SYM, 100, 0, 20, 0, 0, 0 },

--- 195,203 -----
   	{ "lamp", "lamp", NULL, 0, 0, TOOL_SYM, 10, 0, 10, 0, 0, 0 },
   	{ "magic lamp", "lamp", NULL, 0, 0, TOOL_SYM, 2, 0, 10, 0, 0, 0 },
   	{ "badge", "badge", NULL, 0, 0, TOOL_SYM, 1, 0, 2, 0, 0, 0 },
+ #ifdef YODA
+ 	{ "battery", NULL, NULL, 1, 0, TOOL_SYM, 2, 0, 1, 500, 0, 0 },
+ #endif
  
  	{ "heavy iron ball", NULL, NULL, 1, 0,
  		BALL_SYM, 100, 0, 20, 0, 0, 0 },
*** options.c.orig	Wed May 11 11:00:13 1988
--- options.c	Wed May 11 09:56:37 1988
***************
*** 51,56
  		*op++ = 0;
  		parseoptions(op, from_env);
  	}
  	if(op = index(opts, ' ')) {
  		op2 = op;
  		while(*op++)

--- 51,57 -----
  		*op++ = 0;
  		parseoptions(op, from_env);
  	}
+ #ifndef JCC
  	if(op = index(opts, ' ')) {
  		op2 = op;
  		while(*op++)
***************
*** 56,61
  		while(*op++)
  			if(*op != ' ') *op2++ = *op;
  	}
  	if(!*opts) return;
  	negated = FALSE;
  	while((*opts == '!') || !strncmp(opts, "no", 2)) {

--- 57,63 -----
  		while(*op++)
  			if(*op != ' ') *op2++ = *op;
  	}
+ #endif
  	if(!*opts) return;
  	negated = FALSE;
  	while((*opts == '!') || !strncmp(opts, "no", 2)) {
***************
*** 237,242
   * or SINKS in or out and forget to change the tail entries in your graphics
   * string.
   */
  #define SETPCHAR(f, n)	showsyms.f = (strlen(opts) > n) ? opts[n] : defsyms.f
  		SETPCHAR(stone, 0);
  		SETPCHAR(vwall, 1);

--- 239,282 -----
   * or SINKS in or out and forget to change the tail entries in your graphics
   * string.
   */
+ #ifdef JCC
+ #define SETPCHAR(f, n)	showsyms.f = ((strlen(opts) > n+1) ?\
+ 		        (opts[n+1] == 'g' ? opts[n] | 0x80 : opts[n]) \
+ 			: defsyms.f)
+ 		SETPCHAR(stone, 0);
+ 		SETPCHAR(vwall, 2);
+ 		SETPCHAR(hwall, 4);
+ 		SETPCHAR(tlcorn, 6);
+ 		SETPCHAR(trcorn, 8);
+ 		SETPCHAR(blcorn, 10);
+ 		SETPCHAR(brcorn, 12);
+ 		SETPCHAR(door, 14);
+ 		SETPCHAR(room, 16);
+ 		SETPCHAR(corr, 18);
+ 		SETPCHAR(upstair, 20);
+ 		SETPCHAR(dnstair, 22);
+ 		SETPCHAR(trap, 24);
+ #ifdef FOUNTAINS
+ 		SETPCHAR(pool, 26);
+ 		SETPCHAR(fountain, 28);
+ #endif
+ #ifdef NEWCLASS
+ 		SETPCHAR(throne, 30);
+ #endif
+ #ifdef SPIDERS
+ 		SETPCHAR(web, 32);
+ #endif
+ #ifdef SINKS
+ 		SETPCHAR(sink, 34);
+ #endif
+ 		SETPCHAR(crwall,36);
+ 		SETPCHAR(twall,38);
+ 		SETPCHAR(tdwall,40);
+ 		SETPCHAR(tlwall,42);
+ 		SETPCHAR(trwall,44);
+ #undef SETPCHAR
+ 
+ #else
  #define SETPCHAR(f, n)	showsyms.f = (strlen(opts) > n) ? opts[n] : defsyms.f
  		SETPCHAR(stone, 0);
  		SETPCHAR(vwall, 1);
***************
*** 265,270
  		SETPCHAR(sink, 17);
  #endif
  #undef SETPCHAR
  		return;
  	}
  #endif /* GRAPHICS */

--- 305,311 -----
  		SETPCHAR(sink, 17);
  #endif
  #undef SETPCHAR
+ #endif /* JCC */
  		return;
  	}
  #endif /* GRAPHICS */
*** pcmain.c.orig	Wed May 11 11:25:59 1988
--- pcmain.c	Wed May 11 09:56:38 1988
***************
*** 320,325
  			if(Glib) glibr();
  			timeout();
  			++moves;
  #ifdef PRAYERS
  			if (u.ublesscnt)  u.ublesscnt--;
  #endif

--- 320,337 -----
  			if(Glib) glibr();
  			timeout();
  			++moves;
+ #ifdef YODA
+ 			if (uwep && uwep->otyp == LIGHT_SWORD) {
+ 				OPOWER(uwep)--;
+ 				if (OPOWER(uwep) == 50 && !Blind) 
+ 					pline("The blade of your %s seems dimmer.",xname(uwep));
+ 				if (OPOWER(uwep) <= 0) {
+ 					if (!Blind) 
+ 						pline("The blade of your %s disappears!",xname(uwep));
+ 					uwep->otyp = SWORD_HILT;
+ 				}
+ 			}
+ #endif
  #ifdef PRAYERS
  			if (u.ublesscnt)  u.ublesscnt--;
  #endif
*** polyself.c.orig	Wed May 11 11:26:41 1988
--- polyself.c	Wed May 11 09:56:39 1988
***************
*** 192,197
  	  if (cantwield(turninto)) {
  	       pline("You find you must drop your weapon!");
  	       setuwep((struct obj *)0);
  	       dropx(otmp);
  	  }
       }

--- 192,201 -----
  	  if (cantwield(turninto)) {
  	       pline("You find you must drop your weapon!");
  	       setuwep((struct obj *)0);
+ #ifdef YODA
+ 		if (otmp->otyp == LIGHT_SWORD) 
+ 			otmp->otyp = SWORD_HILT;
+ #endif
  	       dropx(otmp);
  	  }
       }
*** pri.c.orig	Wed May 11 11:28:28 1988
--- pri.c	Wed May 11 11:28:54 1988
***************
*** 9,14
  #ifdef MSDOSCOLOR
  extern int hilite();
  #endif
  xchar scrlx, scrhx, scrly, scrhy;	/* corners of new area on screen */
  
  extern char *hu_stat[];	/* in eat.c */

--- 9,17 -----
  #ifdef MSDOSCOLOR
  extern int hilite();
  #endif
+ #ifdef JCC
+ static char GFlag = 0;	/* graphic flag */
+ #endif
  xchar scrlx, scrhx, scrly, scrhy;	/* corners of new area on screen */
  
  extern char *hu_stat[];	/* in eat.c */
***************
*** 98,103
  #ifdef MSDOSCOLOR
  		hilite(ch);
  #else
  		(void) putchar(ch);
  #endif
  	curx++;

--- 101,121 -----
  #ifdef MSDOSCOLOR
  		hilite(ch);
  #else
+ #ifdef JCC
+ 		if (ch & 0x80) {
+ 			if (!GFlag) {
+ 				graph_on();
+ 				GFlag = 1;
+ 			}
+ 			(void) putchar(ch ^ 0x80);
+ 		} else {
+ 			if (GFlag) {
+ 				graph_off();
+ 				GFlag = 0;
+ 			}
+ 			(void) putchar(ch);
+ 		}
+ #else
  		(void) putchar(ch);
  #endif 	/* JCC */
  #endif
***************
*** 99,104
  		hilite(ch);
  #else
  		(void) putchar(ch);
  #endif
  	curx++;
  }

--- 117,123 -----
  		}
  #else
  		(void) putchar(ch);
+ #endif 	/* JCC */
  #endif
  	curx++;
  }
***************
*** 196,201
  			} else if(room->seen)
  				at(x,y,room->scrsym);
  #endif
  	scrlx = COLNO;
  	scrly = ROWNO;
  	scrhx = scrhy = 0;

--- 215,226 -----
  			} else if(room->seen)
  				at(x,y,room->scrsym);
  #endif
+ #ifdef JCC
+ 	if (GFlag) {
+ 		graph_off();
+ 		GFlag = 0;
+ 	}
+ #endif
  	scrlx = COLNO;
  	scrly = ROWNO;
  	scrhx = scrhy = 0;
***************
*** 245,250
  			DECgraphicsOFF();
  	}
  #endif
  	if(ymax > ROWNO) {
  		cornbot(xmin-1);
  		if(ymax > ROWNO+1 && CD) {

--- 270,281 -----
  			DECgraphicsOFF();
  	}
  #endif
+ #ifdef JCC
+ 	if (GFlag) {
+ 		graph_off();
+ 		GFlag = 0;
+ 	}
+ #endif
  	if(ymax > ROWNO) {
  		cornbot(xmin-1);
  		if(ymax > ROWNO+1 && CD) {
***************
*** 328,333
  		mon->mdx = mon->mx;
  		mon->mdy = mon->my;
  	}
  }
  
  unpmon(mon) register struct monst *mon; {

--- 359,370 -----
  		mon->mdx = mon->mx;
  		mon->mdy = mon->my;
  	}
+ #ifdef JCC
+ 	if (GFlag) {
+ 		graph_off();
+ 		GFlag = 0;
+ 	}
+ #endif
  }
  
  unpmon(mon) register struct monst *mon; {
***************
*** 350,355
  				room->new = 0;
  				at(x,y,room->scrsym);
  			}
  	scrhx = scrhy = 0;
  	scrlx = COLNO;
  	scrly = ROWNO;

--- 387,398 -----
  				room->new = 0;
  				at(x,y,room->scrsym);
  			}
+ #ifdef JCC
+ 	if (GFlag) {
+ 		graph_off();
+ 		GFlag = 0;
+ 	}
+ #endif
  	scrhx = scrhy = 0;
  	scrlx = COLNO;
  	scrly = ROWNO;
*** prisym.c.orig	Wed May 11 11:31:31 1988
--- prisym.c	Wed May 11 11:30:47 1988
***************
*** 215,220
  		tmp = room->scrsym;	/* %% wrong after killing mimic ! */
  		break;
  	case HWALL:
  		tmp = room->scrsym;	/* OK for corners only */
  		if (!IS_CORNER(tmp))
  			tmp = HWALL_SYM;

--- 215,221 -----
  		tmp = room->scrsym;	/* %% wrong after killing mimic ! */
  		break;
  	case HWALL:
+ #ifndef JCC
  		tmp = room->scrsym;	/* OK for corners only */
  		if (!IS_CORNER(tmp))
  #endif
***************
*** 217,222
  	case HWALL:
  		tmp = room->scrsym;	/* OK for corners only */
  		if (!IS_CORNER(tmp))
  			tmp = HWALL_SYM;
  		break;
  	case VWALL:

--- 218,224 -----
  #ifndef JCC
  		tmp = room->scrsym;	/* OK for corners only */
  		if (!IS_CORNER(tmp))
+ #endif
  			tmp = HWALL_SYM;
  		break;
  	case VWALL:
***************
*** 222,227
  	case VWALL:
  		tmp = VWALL_SYM;
  		break;
  	case LDOOR:
  	case DOOR:
  		tmp = DOOR_SYM;

--- 224,258 -----
  	case VWALL:
  		tmp = VWALL_SYM;
  		break;
+ #ifdef JCC
+ 	case TLCORNER:
+ 		tmp = TLCORN_SYM;
+ 		break;
+ 	case TRCORNER:
+ 		tmp = TRCORN_SYM;
+ 		break;
+ 	case BLCORNER:
+ 		tmp = BLCORN_SYM;
+ 		break;
+ 	case BRCORNER:
+ 		tmp = BRCORN_SYM;
+ 		break;
+ 	case CROSSWALL:
+ 		tmp = CRWALL_SYM;
+ 		break;
+ 	case TUPWALL:
+ 		tmp = TUPWALL_SYM;
+ 		break;
+ 	case TDOWNWALL:
+ 		tmp = TDOWNWALL_SYM;
+ 		break;
+ 	case TLEFTWALL:
+ 		tmp = TLEFTWALL_SYM;
+ 		break;
+ 	case TRIGHTWALL:
+ 		tmp = TRIGHTWALL_SYM;
+ 		break;
+ #endif
  	case LDOOR:
  	case DOOR:
  		tmp = DOOR_SYM;
*** rm.h.orig	Wed May 11 11:32:33 1988
--- rm.h	Wed May 11 09:56:43 1988
***************
*** 11,16
  /* Level location types */
  #define	HWALL 1
  #define	VWALL 2
  #define	SDOOR 3
  #define	SCORR 4
  #define	LDOOR 5

--- 11,39 -----
  /* Level location types */
  #define	HWALL 1
  #define	VWALL 2
+ #ifdef JCC
+ #define TLCORNER	3
+ #define TRCORNER	4
+ #define BLCORNER	5
+ #define BRCORNER	6
+ #define CROSSWALL	7	/* From here to TRIGHTWALL, only used in */
+ #define TUPWALL		8	/* Mazes, in order to make it pretty ! */
+ #define TDOWNWALL	9
+ #define TLEFTWALL	10
+ #define TRIGHTWALL	11
+ #define	SDOOR		12
+ #define	SCORR		13
+ #define	LDOOR		14
+ #define	POOL		15	/* not yet fully implemented */
+ 				/* this should in fact be a bit like lit */
+ #define	DOOR	  	16
+ #define	CORR	  	17
+ #define	ROOM	  	18
+ #define	STAIRS 	 	19
+ #define FOUNTAIN 	20
+ #define THRONE	 	21
+ #define	SINK	 	22
+ #else
  #define	SDOOR 3
  #define	SCORR 4
  #define	LDOOR 5
***************
*** 23,28
  #define FOUNTAIN 11
  #define THRONE	 12
  #define	SINK	 13
  /*
   * Avoid using the level types in inequalities:
   *  these types are subject to change.

--- 46,52 -----
  #define FOUNTAIN 11
  #define THRONE	 12
  #define	SINK	 13
+ #endif
  /*
   * Avoid using the level types in inequalities:
   *  these types are subject to change.
***************
*** 28,33
   *  these types are subject to change.
   * Instead, use one of the macros below.
   */
  #define	IS_WALL(typ)	((typ) <= VWALL)
  #define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
  #define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */

--- 52,60 -----
   *  these types are subject to change.
   * Instead, use one of the macros below.
   */
+ #ifdef JCC
+ #define	IS_WALL(typ)	((typ) <= TRIGHTWALL)
+ #else
  #define	IS_WALL(typ)	((typ) <= VWALL)
  #endif
  #define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
***************
*** 29,34
   * Instead, use one of the macros below.
   */
  #define	IS_WALL(typ)	((typ) <= VWALL)
  #define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
  #define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */
  #define	IS_ROOM(typ)		((typ) >= ROOM)		/* ROOM or STAIRS */

--- 56,62 -----
  #define	IS_WALL(typ)	((typ) <= TRIGHTWALL)
  #else
  #define	IS_WALL(typ)	((typ) <= VWALL)
+ #endif
  #define IS_ROCK(typ)	((typ) < POOL)		/* absolutely nonaccessible */
  #define	ACCESSIBLE(typ)	((typ) >= DOOR)			/* good position */
  #define	IS_ROOM(typ)		((typ) >= ROOM)		/* ROOM or STAIRS */
***************
*** 89,94
  #ifdef SINKS
      unsigned char sink;
  #endif
  };
  extern struct symbols showsyms, defsyms;
  

--- 117,125 -----
  #ifdef SINKS
      unsigned char sink;
  #endif
+ #ifdef JCC
+     unsigned char crwall, twall, tdwall, tlwall, trwall;
+ #endif
  };
  extern struct symbols showsyms, defsyms;
  
***************
*** 110,115
  #define THRONE_SYM      showsyms.throne
  #define WEB_SYM         showsyms.web
  #define SINK_SYM	showsyms.sink
  #endif
  
  #define	ERRCHAR	']'

--- 141,153 -----
  #define THRONE_SYM      showsyms.throne
  #define WEB_SYM         showsyms.web
  #define SINK_SYM	showsyms.sink
+ #ifdef JCC
+ #define CRWALL_SYM	showsyms.crwall
+ #define TUPWALL_SYM	showsyms.twall
+ #define TDOWNWALL_SYM	showsyms.tdwall
+ #define TLEFTWALL_SYM	showsyms.tlwall
+ #define TRIGHTWALL_SYM	showsyms.trwall
+ #endif
  #endif
  
  #define	ERRCHAR	']'
*** save.c.orig	Wed May 11 11:33:13 1988
--- save.c	Wed May 11 09:56:44 1988
***************
*** 8,13
  extern char genocided[60];		/* defined in decl.c */
  extern char fut_geno[60];		/* idem */
  extern struct permonst	pm_wizard;	/* since the wizard evolves */
  
  extern char SAVEF[], nul[];
  extern char pl_character[PL_CSIZ];

--- 8,16 -----
  extern char genocided[60];		/* defined in decl.c */
  extern char fut_geno[60];		/* idem */
  extern struct permonst	pm_wizard;	/* since the wizard evolves */
+ #ifdef YODA
+ extern char FirstTime;			/* first use of light sword */
+ #endif
  
  extern char SAVEF[], nul[];
  extern char pl_character[PL_CSIZ];
***************
*** 97,102
  #ifdef HARD
  	bwrite(fd, (char *) &pm_wizard, sizeof(struct permonst));
  #endif
  	savenames(fd);
  #ifdef DGK
  	if (mode == COUNT) {

--- 100,108 -----
  #ifdef HARD
  	bwrite(fd, (char *) &pm_wizard, sizeof(struct permonst));
  #endif
+ #ifdef YODA
+ 	bwrite(fd, (char *) &FirstTime, sizeof FirstTime);
+ #endif
  	savenames(fd);
  #ifdef DGK
  	if (mode == COUNT) {
***************
*** 218,223
  	mread(fd, (char *) &pm_wizard, sizeof(struct permonst));
  	pm_wizard.mname = name;
  	}
  #endif
  	restnames(fd);
  #ifdef DGK

--- 224,232 -----
  	mread(fd, (char *) &pm_wizard, sizeof(struct permonst));
  	pm_wizard.mname = name;
  	}
+ #endif
+ #ifdef YODA
+ 	mread(fd, (char *) &FirstTime, sizeof FirstTime);
  #endif
  	restnames(fd);
  #ifdef DGK
*** steal.c.orig	Wed May 11 11:34:30 1988
--- steal.c	Wed May 11 11:38:39 1988
***************
*** 157,162
  	}
  	freeinv(otmp);
  	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
  	mpickobj(mtmp,otmp);
  	return((multi < 0) ? 0 : 1);
  }

--- 157,176 -----
  	}
  	freeinv(otmp);
  	pline("%s stole %s.", named ? "She" : Monnam(mtmp), doname(otmp));
+ #ifdef YODA
+ 	if (otmp->otyp == LIGHT_SWORD) 
+ 		otmp->otyp = SWORD_HILT;
+ #endif
+ 	if (otmp->otyp == BLINDFOLD && Blindfolded && otmp->owornmask) {
+ 	    Blindfolded = 0;
+ 	    if (!Blinded)	Blinded = 1;	/* see on next move */
+ 	    else		pline("You still cannot see.");
+ 	    otmp->owornmask = 0;
+ 	}
+ 	if (otmp->otyp == BADGE && Badged && otmp->owornmask) {
+ 		Badged = 0;
+ 		otmp->owornmask = 0;
+ 	}
  	mpickobj(mtmp,otmp);
  	return((multi < 0) ? 0 : 1);
  }
*** termcap.c.orig	Wed May 11 11:39:54 1988
--- termcap.c	Wed May 11 12:25:18 1988
***************
*** 23,28
  static char tbuf[512];
  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
  static char *VS, *VE, *US, *UE;
  static int SG;
  static char PC = '\0';
  char *CD;		/* tested in pri.c: docorner() */

--- 23,31 -----
  static char tbuf[512];
  static char *HO, *CL, *CE, *UP, *CM, *ND, *XD, *BC, *SO, *SE, *TI, *TE;
  static char *VS, *VE, *US, *UE;
+ #ifdef JCC
+ static char *AS, *AE;
+ #endif
  static int SG;
  static char PC = '\0';
  char *CD;		/* tested in pri.c: docorner() */
***************
*** 113,118
  #ifdef MSDOSCOLOR
  	init_hilite();
  #endif
  }
  
  start_screen()

--- 116,125 -----
  #ifdef MSDOSCOLOR
  	init_hilite();
  #endif
+ #ifdef JCC
+ 	AS = tgetstr("as",&tbufptr);
+ 	AE = tgetstr("ae",&tbufptr);
+ #endif
  }
  
  start_screen()
***************
*** 397,399
  
  #endif
  

--- 404,419 -----
  
  #endif
  
+ #ifdef JCC
+ void
+ graph_on()
+ {
+ 	if (AS) xputs(AS);
+ }
+ 
+ void
+ graph_off()
+ {
+ 	if (AE) xputs(AE);
+ }
+ #endif /* JCC */
*** u_init.c.orig	Wed May 11 11:41:00 1988
--- u_init.c	Wed May 11 10:22:46 1988
***************
*** 30,35
  #ifdef KAA
  	"Valkyrie", "Elf", "Healer",
  #endif
  	"Wizard"
  };
  #define	NR_OF_ROLES	SIZE(roles)

--- 30,38 -----
  #ifdef KAA
  	"Valkyrie", "Elf", "Healer",
  #endif
+ #ifdef YODA
+ 	"Jedi-knight",
+ #endif
  	"Wizard"
  };
  #define	NR_OF_ROLES	SIZE(roles)
***************
*** 198,203
  };
  #endif /* NEWCLASS /**/
  
  u_init(){
  register int i;
  char exper = 'y', pc;

--- 201,213 -----
  };
  #endif /* NEWCLASS /**/
  
+ #ifdef YODA
+ struct	trobj	Jedi[] = {
+ 	{ LIGHT_SWORD, 1, WEAPON_SYM, 1, 1 },
+ 	{ ELVEN_CLOAK, 0, ARMOR_SYM, 1, 1},
+ 	{ 0, 0, 0, 0, 0 }
+ };
+ #endif /* YODA */
  u_init(){
  register int i;
  char exper = 'y', pc;
***************
*** 454,459
  		objects[POT_HOLY_WATER].oc_name_known = 1;
  		break;
  #endif /* NEWCLASS /**/
  	default:	/* impossible */
  		u.uhp = u.uhpmax = 12;
  		u.ustr = u.ustrmax = 16;

--- 464,482 -----
  		objects[POT_HOLY_WATER].oc_name_known = 1;
  		break;
  #endif /* NEWCLASS /**/
+ #ifdef YODA
+ 	case 'j':
+ 	case 'J':
+ 		Fast = INTRINSIC;
+ 		Stealth = INTRINSIC;
+ 		u.uhp = u.uhpmax = 15;
+ 		u.ustr = u.ustrmax = 10;
+ 		ini_inv(Jedi);
+ 		ini_batteries();
+ 		if(!rn2(5)) ini_inv(Blindfold);
+ 		OPOWER(uwep) = rn1(300,200);
+ 		break;
+ #endif /* YODA */
  	default:	/* impossible */
  		u.uhp = u.uhpmax = 12;
  		u.ustr = u.ustrmax = 16;
***************
*** 473,478
  		u.ustr++, u.ustrmax++;
  }
  
  
  ini_inv(trop) register struct trobj *trop; {
  register struct obj *obj;

--- 496,512 -----
  		u.ustr++, u.ustrmax++;
  }
  
+ #ifdef YODA
+ ini_batteries()
+ {	register struct obj *obj;
+ 	extern struct obj *mksobj();
+ 	obj = mksobj(BATTERY);
+ 	obj->known = 0;
+ 	obj->quan = !rn2(6) ? rn1(2,4) : rn1(2,2);
+ 	obj->owt = weight(obj);
+ 	(void)addinv(obj);
+ }
+ #endif
  
  ini_inv(trop) register struct trobj *trop; {
  register struct obj *obj;
*** unixmain.c.orig	Wed May 11 11:41:34 1988
--- unixmain.c	Wed May 11 09:56:58 1988
***************
*** 285,290
  			if(Glib) glibr();
  			timeout();
  			++moves;
  #ifdef PRAYERS
  			if (u.ublesscnt)  u.ublesscnt--;
  #endif

--- 285,302 -----
  			if(Glib) glibr();
  			timeout();
  			++moves;
+ #ifdef YODA
+ 			if (uwep && uwep->otyp == LIGHT_SWORD) {
+ 				OPOWER(uwep)--;
+ 				if (OPOWER(uwep) == 50 && !Blind) 
+ 					pline("The blade of your %s seems dimmer.",xname(uwep));
+ 				if (OPOWER(uwep) <= 0) {
+ 					if (!Blind) 
+ 						pline("The blade of your %s disappears!",xname(uwep));
+ 					uwep->otyp = SWORD_HILT;
+ 				}
+ 			}
+ #endif
  #ifdef PRAYERS
  			if (u.ublesscnt)  u.ublesscnt--;
  #endif
*** wield.c.orig	Wed May 11 11:42:41 1988
--- wield.c	Wed May 11 09:57:00 1988
***************
*** 7,12
  #ifdef KAA
  extern boolean unweapon;
  #endif
  
  setuwep(obj) register struct obj *obj; {
  	setworn(obj, W_WEP);

--- 7,15 -----
  #ifdef KAA
  extern boolean unweapon;
  #endif
+ #ifdef YODA
+ char FirstTime = 1;	/* first use of the light sword */
+ #endif
  
  setuwep(obj) register struct obj *obj; {
  	setworn(obj, W_WEP);
***************
*** 31,36
  	  } else if (welded(uwep))
  		pline("The %s welded to your hand!",aobjnam(uwep,"are"));
  	  	else  {
  	  	  setuwep((struct obj *) 0);
  	  	  res++;
  	  	  pline("You are empty handed.");

--- 34,46 -----
  	  } else if (welded(uwep))
  		pline("The %s welded to your hand!",aobjnam(uwep,"are"));
  	  	else  {
+ #ifdef YODA
+ 		  if (uwep->otyp == LIGHT_SWORD) {
+ 			  if (!Blind) 
+ 				  pline("The blade of light disappears!");
+ 			  uwep->otyp = SWORD_HILT;
+ 		  }
+ #endif
  	  	  setuwep((struct obj *) 0);
  	  	  res++;
  	  	  pline("You are empty handed.");
***************
*** 51,56
  	else if(wep->owornmask & (W_ARMOR | W_RING))
  		pline("You cannot wield that!");
  	else {
  		setuwep(wep);
  		res++;
  		if(welded(uwep))

--- 61,87 -----
  	else if(wep->owornmask & (W_ARMOR | W_RING))
  		pline("You cannot wield that!");
  	else {
+ #ifdef YODA
+ 		if (uwep->otyp == LIGHT_SWORD) {
+ 			if (!Blind) 
+ 				pline("The blade of light disappears!");
+ 			uwep->otyp = SWORD_HILT;
+ 		}
+ 		if (wep->otyp ==  SWORD_HILT && OPOWER(wep) > 0) {
+ 			if (FirstTime) {
+ 				pline("As you grab the %s, your thumb",xname(wep));
+ 				pline("press an hidden button. Click !!");
+ 				if (!Blind) 
+ 					pline("A blade of light appears from the hilt!");
+ 				pline("You ear a distant voice saying :");
+ 				pline("'May the Source be with you...'");
+ 				FirstTime = 0;
+ 			} else
+ 				if (!Blind) 
+ 					pline("A blade of light appears from the hilt!");
+ 			wep->otyp = LIGHT_SWORD;
+ 		}
+ #endif
  		setuwep(wep);
  		res++;
  		if(welded(uwep))
***************
*** 69,74
  
  corrode_weapon(){
  	if(!uwep || uwep->olet != WEAPON_SYM) return;	/* %% */
  	if(uwep->rustfree)
  		pline("Your %s not affected.", aobjnam(uwep, "are"));
  	else if (uwep->spe > -6) {

--- 100,129 -----
  
  corrode_weapon(){
  	if(!uwep || uwep->olet != WEAPON_SYM) return;	/* %% */
+ #ifdef YODA
+ 	if (uwep->otyp == LIGHT_SWORD) {
+ 		/* the light sword is really a very delicate
+ 		   weapon */
+ 		struct obj *obj;
+ 		obj = uwep;
+ 		pline("An extremely powerful lightning bolt erupts from your sword,");
+ 		pline("destroying it and getting you blasted!");
+ 		freeinv(obj);	/* Destroy the sword */
+ 		setworn((struct obj *) 0, obj->owornmask);
+ 		obfree(obj, (struct obj *) 0);
+ 		losehp(rn2(40),"lightning bolt");
+ 	} else 
+ 	if (uwep->otyp == SWORD_HILT) {
+ 		struct obj *obj;
+ 		obj = uwep;
+ 		pline("Your sword hilt melts into non descriptible magma,");
+ 		pline("hurting your hand very badly !!!");
+ 		freeinv(obj);	/* Destroy the hilt */
+ 		setworn((struct obj *) 0, obj->owornmask);
+ 		obfree(obj, (struct obj *) 0);
+ 		losehp(rn2(10),"acid magma");		
+ 	} else
+ #endif
  	if(uwep->rustfree)
  		pline("Your %s not affected.", aobjnam(uwep, "are"));
  	else if (uwep->spe > -6) {
*** zap.c.orig	Wed May 11 11:43:42 1988
--- zap.c	Wed May 11 10:24:00 1988
***************
*** 1207,1212
     if successful. */
  	if (otmp) { 
  #endif
  		wishquan = otmp->quan;
  		otmp = addinv(otmp);
  		/* indented lines added below so quantity shows

--- 1207,1218 -----
     if successful. */
  	if (otmp) { 
  #endif
+ #ifdef YODA
+ 		if (otmp->otyp == LIGHT_SWORD) 
+ 			otmp->otyp = SWORD_HILT;
+ 		if (otmp->otyp == SWORD_HILT) 
+ 			OPOWER(otmp) = rnd(500);
+ #endif
  		wishquan = otmp->quan;
  		otmp = addinv(otmp);
  		/* indented lines added below so quantity shows


